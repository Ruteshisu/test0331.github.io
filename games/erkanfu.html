<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>シンプル格闘ゲーム（操作デモ）</title>
  <style>
    body {
      margin: 0;
      background: #222;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }
    canvas {
      border: 2px solid #fff;
      background-color: #333;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="640" height="360"></canvas>
  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    const keys = {};
    let hitboxes = [];
    let enemyHitboxes = [];
    let stage = 1;
    let stageCleared = false;
    let clearTimer = 0;
    let startTime = Date.now();
    let hitStop = false;
    let hitStopTimer = 0;
    let shakeOffset = { x: 0, y: 0 };
    let enemyState = "idle";
    let enemyAttackCooldown = 0;

    const player = {
      x: 100,
      y: 260,
      width: 30,
      height: 60,
      vx: 0,
      vy: 0,
      onGround: true,
      state: "idle",
      hp: 10
    };

    const enemy = {
      x: 460,
      y: 260,
      width: 30,
      height: 60,
      hp: 10,
      hit: false,
      hitTime: 0
    };

    const GRAVITY = 0.5;
    const FLOOR_Y = 320;

    function resetStage() {
      player.x = 100;
      player.hp = 10;
      enemy.x = 460;
      enemy.hp = 10;
      stageCleared = false;
      startTime = Date.now();
      enemyAttackCooldown = 0;
    }

    function createHitbox(type) {
      const now = Date.now();
      const existing = hitboxes.find(h => h.type === type && now - h.timestamp < 200);
      if (existing) return;

      const facingRight = player.x < enemy.x;
      const offsetX = facingRight ? (type === "punch" ? player.width : player.width + 10) : (type === "punch" ? -20 : -30);
      const width = type === "punch" ? 20 : 30;
      const height = 20;
      const x = player.x + offsetX;

      hitboxes.push({ x, y: player.y + 20, width, height, timestamp: now, type, hitDone: false });
    }

    function createEnemyHitbox() {
      const now = Date.now();
      const offsetX = player.x < enemy.x ? -20 : enemy.width;
      enemyHitboxes.push({ x: enemy.x + offsetX, y: enemy.y + 20, width: 20, height: 20, timestamp: now, hitDone: false });
    }

    function updateEnemy() {
      if (stageCleared || hitStop || enemy.hp <= 0) return;

      const dx = player.x - enemy.x;
      if (Math.abs(dx) > 40) {
        enemy.x += dx > 0 ? 1 : -1;
        enemyState = "move";
      } else {
        if (Date.now() > enemyAttackCooldown) {
          if (Math.random() < 0.03) {
            enemyState = "attack";
            createEnemyHitbox();
            enemyAttackCooldown = Date.now() + 800 + Math.random() * 1000;
          } else {
            enemyState = "idle";
          }
        }
      }
    }

    function updateEnemyHitboxes() {
      const now = Date.now();
      enemyHitboxes = enemyHitboxes.filter(h => {
        const active = now - h.timestamp < 200;
        if (active && checkCollision(h, player) && !h.hitDone) {
          player.hp = Math.max(0, player.hp - 1);
          h.hitDone = true;
          hitStop = true;
          hitStopTimer = now;
          shakeOffset.x = Math.random() * 6 - 3;
          shakeOffset.y = Math.random() * 6 - 3;
        }
        return active;
      });
    }

    function checkCollision(a, b) {
  return (
    a.x < b.x + b.width &&
    a.x + a.width > b.x &&
    a.y < b.y + b.height &&
    a.y + a.height > b.y
  );
}

function drawStage() {
  ctx.fillStyle = "#444";
  ctx.fillRect(0, FLOOR_Y, canvas.width, canvas.height - FLOOR_Y);
}

function drawPlayer() {
  switch (player.state) {
    case "idle": ctx.fillStyle = "white"; break;
    case "move": ctx.fillStyle = "lightblue"; break;
    case "jump": ctx.fillStyle = "orange"; break;
    case "punch": ctx.fillStyle = "red"; break;
    case "kick": ctx.fillStyle = "yellow"; break;
    default: ctx.fillStyle = "gray";
  }
  ctx.fillRect(player.x, player.y, player.width, player.height);
}

function drawEnemy() {
  const now = Date.now();
  if (enemy.hit && now - enemy.hitTime < 300) {
    ctx.fillStyle = "red";
  } else {
    ctx.fillStyle = "green";
    enemy.hit = false;
  }
  ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
}

function drawHitboxes() {
  ctx.fillStyle = "rgba(255, 0, 0, 0.6)";
  hitboxes.forEach(h => {
    ctx.fillRect(h.x, h.y, h.width, h.height);
  });
  ctx.fillStyle = "rgba(255, 255, 0, 0.4)";
  enemyHitboxes.forEach(h => {
    ctx.fillRect(h.x, h.y, h.width, h.height);
  });
}

function drawHPBar(x, y, hp, label) {
  ctx.fillStyle = "white";
  ctx.fillText(label, x, y - 5);
  ctx.fillStyle = "red";
  ctx.fillRect(x, y, 100, 10);
  ctx.fillStyle = "lime";
  ctx.fillRect(x, y, hp * 10, 10);
}

function drawClearText() {
  ctx.fillStyle = "white";
  ctx.font = "32px sans-serif";
  ctx.fillText("CLEAR!", canvas.width / 2 - 60, canvas.height / 2);
}

function drawStartText() {
  ctx.fillStyle = "white";
  ctx.font = "32px sans-serif";
  ctx.fillText("START!", canvas.width / 2 - 60, canvas.height / 2);
}

function updatePlayer() {
  if (stageCleared || hitStop) return;
  if (keys["ArrowLeft"]) {
    player.vx = -3;
    player.state = "move";
  } else if (keys["ArrowRight"]) {
    player.vx = 3;
    player.state = "move";
  } else {
    player.vx = 0;
    if (player.onGround) player.state = "idle";
  }
  if (keys["ArrowUp"] && player.onGround) {
    player.vy = -10;
    player.onGround = false;
    player.state = "jump";
  }
  player.x += player.vx;
  player.y += player.vy;
  if (!player.onGround) {
    player.vy += GRAVITY;
    if (player.y >= FLOOR_Y - player.height) {
      player.y = FLOOR_Y - player.height;
      player.vy = 0;
      player.onGround = true;
    }
  }
  if (keys["z"]) {
    player.state = "punch";
    createHitbox("punch");
    keys["z"] = false;
  } else if (keys["x"]) {
    player.state = "kick";
    createHitbox("kick");
    keys["x"] = false;
  }
}

    function updateHitboxes() {
  const now = Date.now();
  hitboxes = hitboxes.filter(h => {
    const stillActive = now - h.timestamp < 200;
    if (stillActive && checkCollision(h, enemy) && enemy.hp > 0 && !h.hitDone) {
      enemy.hp = Math.max(0, enemy.hp - 1);
      enemy.hit = true;
      enemy.hitTime = now;
      h.hitDone = true;
      hitStop = true;
      hitStopTimer = now;
      shakeOffset.x = Math.random() * 6 - 3;
      shakeOffset.y = Math.random() * 6 - 3;
    }
    return stillActive;
  });
}

function gameLoop() {
      const now = Date.now();
      if (hitStop && now - hitStopTimer > 100) {
        hitStop = false;
        shakeOffset = { x: 0, y: 0 };
      }

      ctx.save();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.translate(shakeOffset.x, shakeOffset.y);

      drawStage();

      if (now - startTime < 2000) {
        drawStartText();
      } else if (!stageCleared && !hitStop) {
        updatePlayer();
        updateHitboxes();
        updateEnemy();
        updateEnemyHitboxes();
      }

      drawPlayer();
      drawEnemy();
      drawHitboxes();
      drawHPBar(20, 20, player.hp, "PLAYER");
      drawHPBar(canvas.width - 120, 20, enemy.hp, "ENEMY");

      if (enemy.hp <= 0 && !stageCleared) {
        stageCleared = true;
        clearTimer = now;
      }

      if (stageCleared) {
        drawClearText();
        if (now - clearTimer > 2000) {
          stage++;
          resetStage();
        }
      }

      ctx.restore();
      requestAnimationFrame(gameLoop);
    }

    document.addEventListener("keydown", e => keys[e.key] = true);
    document.addEventListener("keyup", e => keys[e.key] = false);

    gameLoop();
  </script>
</body>
</html>
